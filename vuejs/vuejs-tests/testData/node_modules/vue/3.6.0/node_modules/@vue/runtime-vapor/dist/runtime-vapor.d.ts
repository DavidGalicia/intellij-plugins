import { Plugin, GenericComponentInstance, GenericAppContext, EffectScope as EffectScope$1, EmitFn, SuspenseBoundary, LifecycleHook, NormalizedPropsOptions, ObjectEmitsOptions, ComponentInternalOptions, ComponentPropsOptions, EmitsOptions, CreateAppFunction, DirectiveModifiers } from '@vue/runtime-dom';
import { EffectScope, ShallowRef, Ref } from '@vue/reactivity';
import { NormalizedStyle } from '@vue/shared';

type Block = Node | VaporFragment | DynamicFragment | VaporComponentInstance | Block[];
type BlockFn = (...args: any[]) => Block;
export declare class VaporFragment {
    nodes: Block;
    anchor?: Node;
    insert?: (parent: ParentNode, anchor: Node | null) => void;
    remove?: (parent?: ParentNode) => void;
    constructor(nodes: Block);
}
declare class DynamicFragment extends VaporFragment {
    anchor: Node;
    scope: EffectScope | undefined;
    current?: BlockFn;
    fallback?: BlockFn;
    constructor(anchorLabel?: string);
    update(render?: BlockFn, key?: any): void;
}
export declare function isFragment(val: NonNullable<unknown>): val is VaporFragment;
export declare function insert(block: Block, parent: ParentNode, anchor?: Node | null | 0): void;
export declare function prepend(parent: ParentNode, ...blocks: Block[]): void;
export declare function remove(block: Block, parent?: ParentNode): void;

declare const interopKey: unique symbol;
export declare const vaporInteropPlugin: Plugin;

type RawProps = Record<string, () => unknown> & {
    $?: DynamicPropsSource[] & {
        [interopKey]?: boolean;
    };
};
type DynamicPropsSource = (() => Record<string, unknown>) | Record<string, () => unknown>;

type RawSlots = Record<string, VaporSlot> & {
    $?: DynamicSlotSource[];
};
type StaticSlots = Record<string, VaporSlot>;
type VaporSlot = BlockFn;
type DynamicSlot = {
    name: string;
    fn: VaporSlot;
};
type DynamicSlotFn = () => DynamicSlot | DynamicSlot[];
type DynamicSlotSource = StaticSlots | DynamicSlotFn;
export declare function createSlot(name: string | (() => string), rawProps?: LooseRawProps | null, fallback?: VaporSlot): Block;

type VaporComponent = FunctionalVaporComponent | ObjectVaporComponent;
type VaporSetupFn = (props: any, ctx: Pick<VaporComponentInstance, 'slots' | 'attrs' | 'emit' | 'expose'>) => Block | Record<string, any> | undefined;
type FunctionalVaporComponent = VaporSetupFn & Omit<ObjectVaporComponent, 'setup'> & {
    displayName?: string;
} & SharedInternalOptions;
interface ObjectVaporComponent extends ComponentInternalOptions, SharedInternalOptions {
    setup?: VaporSetupFn;
    inheritAttrs?: boolean;
    props?: ComponentPropsOptions;
    emits?: EmitsOptions;
    render?(ctx: any, props?: any, emit?: EmitFn, attrs?: any, slots?: Record<string, VaporSlot>): Block;
    name?: string;
    vapor?: boolean;
}
interface SharedInternalOptions {
    /**
     * Cached normalized props options.
     * In vapor mode there are no mixins so normalized options can be cached
     * directly on the component
     */
    __propsOptions?: NormalizedPropsOptions;
    /**
     * Cached normalized props proxy handlers.
     */
    __propsHandlers?: [ProxyHandler<any> | null, ProxyHandler<any>];
    /**
     * Cached normalized emits options.
     */
    __emitsOptions?: ObjectEmitsOptions;
}
type LooseRawProps = Record<string, (() => unknown) | DynamicPropsSource[]> & {
    $?: DynamicPropsSource[];
};
type LooseRawSlots = Record<string, VaporSlot | DynamicSlotSource[]> & {
    $?: DynamicSlotSource[];
};
export declare function createComponent(component: VaporComponent, rawProps?: LooseRawProps | null, rawSlots?: LooseRawSlots | null, isSingleRoot?: boolean, appContext?: GenericAppContext): VaporComponentInstance;
declare class VaporComponentInstance implements GenericComponentInstance {
    vapor: true;
    uid: number;
    type: VaporComponent;
    root: GenericComponentInstance | null;
    parent: GenericComponentInstance | null;
    appContext: GenericAppContext;
    block: Block;
    scope: EffectScope$1;
    rawProps: RawProps;
    rawSlots: RawSlots;
    props: Record<string, any>;
    attrs: Record<string, any>;
    propsDefaults: Record<string, any> | null;
    slots: StaticSlots;
    rawPropsRef?: ShallowRef<any>;
    rawSlotsRef?: ShallowRef<any>;
    emit: EmitFn;
    emitted: Record<string, boolean> | null;
    expose: (exposed: Record<string, any>) => void;
    exposed: Record<string, any> | null;
    exposeProxy: Record<string, any> | null;
    refs: Record<string, any>;
    provides: Record<string, any>;
    ids: [string, number, number];
    suspense: SuspenseBoundary | null;
    hasFallthrough: boolean;
    isMounted: boolean;
    isUnmounted: boolean;
    isDeactivated: boolean;
    isUpdating: boolean;
    bc?: LifecycleHook;
    c?: LifecycleHook;
    bm?: LifecycleHook;
    m?: LifecycleHook;
    bu?: LifecycleHook;
    u?: LifecycleHook;
    um?: LifecycleHook;
    bum?: LifecycleHook;
    da?: LifecycleHook;
    a?: LifecycleHook;
    rtg?: LifecycleHook;
    rtc?: LifecycleHook;
    ec?: LifecycleHook;
    sp?: LifecycleHook<() => Promise<unknown>>;
    setupState?: Record<string, any>;
    devtoolsRawSetupState?: any;
    hmrRerender?: () => void;
    hmrReload?: (newComp: VaporComponent) => void;
    propsOptions?: NormalizedPropsOptions;
    emitsOptions?: ObjectEmitsOptions | null;
    isSingleRoot?: boolean;
    constructor(comp: VaporComponent, rawProps?: RawProps | null, rawSlots?: RawSlots | null, appContext?: GenericAppContext);
    /**
     * Expose `getKeysFromRawProps` on the instance so it can be used in code
     * paths where it's needed, e.g. `useModel`
     */
    rawKeys(): string[];
}
export declare function isVaporComponent(value: unknown): value is VaporComponentInstance;
/**
 * Used when a component cannot be resolved at compile time
 * and needs rely on runtime resolution - where it might fallback to a plain
 * element if the resolution fails.
 */
export declare function createComponentWithFallback(comp: VaporComponent | string, rawProps?: LooseRawProps | null, rawSlots?: LooseRawSlots | null, isSingleRoot?: boolean): HTMLElement | VaporComponentInstance;

export declare const createVaporApp: CreateAppFunction<ParentNode, VaporComponent>;
export declare const createVaporSSRApp: CreateAppFunction<ParentNode, VaporComponent>;

/*! #__NO_SIDE_EFFECTS__ */
export declare function defineVaporComponent(comp: VaporComponent, extraOptions?: Omit<ObjectVaporComponent, 'setup'>): VaporComponent;

export type VaporDirective = (node: Element | VaporComponentInstance, value?: () => any, argument?: string, modifiers?: DirectiveModifiers) => (() => void) | void;
type VaporDirectiveArguments = Array<[VaporDirective | undefined] | [VaporDirective | undefined, () => any] | [VaporDirective | undefined, (() => any) | undefined, argument: string] | [
    VaporDirective | undefined,
    value: (() => any) | undefined,
    argument: string | undefined,
    modifiers: DirectiveModifiers
]>;
export declare function withVaporDirectives(node: Element | VaporComponentInstance, dirs: VaporDirectiveArguments): void;

/**
 * This function is called before a block type that requires insertion
 * (component, slot outlet, if, for) is created. The state is used for actual
 * insertion on client-side render, and used for node adoption during hydration.
 */
export declare function setInsertionState(parent: ParentNode, anchor?: Node | 0): void;

export declare function renderEffect(fn: () => void, noLifecycle?: boolean): void;

/*! #__NO_SIDE_EFFECTS__ */
export declare function template(html: string, root?: boolean): () => Node & {
    $root?: true;
};

/*! #__NO_SIDE_EFFECTS__ */
export declare function createTextNode(value?: string): Text;
/*! #__NO_SIDE_EFFECTS__ */
export declare function child(node: ParentNode): Node;
/*! #__NO_SIDE_EFFECTS__ */
export declare function nthChild(node: Node, i: number): Node;
/*! #__NO_SIDE_EFFECTS__ */
export declare function next(node: Node): Node;

type TargetElement = Element & {
    $root?: true;
    $html?: string;
    $cls?: string;
    $sty?: NormalizedStyle | string | undefined;
    value?: string;
    _value?: any;
};
export declare function setProp(el: any, key: string, value: any): void;
export declare function setAttr(el: any, key: string, value: any): void;
export declare function setDOMProp(el: any, key: string, value: any): void;
export declare function setClass(el: TargetElement, value: any): void;
export declare function setStyle(el: TargetElement, value: any): void;
export declare function setValue(el: TargetElement, value: any): void;
/**
 * Only called on text nodes!
 * Compiler should also ensure value passed here is already converted by
 * `toDisplayString`
 */
export declare function setText(el: Text & {
    $txt?: string;
}, value: string): void;
export declare function setHtml(el: TargetElement, value: any): void;
export declare function setDynamicProps(el: any, args: any[]): void;

export declare function on(el: Element, event: string, handler: (e: Event) => any, options?: AddEventListenerOptions & {
    effect?: boolean;
}): void;
export declare function delegate(el: any, event: string, handler: (e: Event) => any): void;
export declare const delegateEvents: (...names: string[]) => void;
export declare function setDynamicEvents(el: HTMLElement, events: Record<string, (...args: any[]) => any>): void;

export declare function createIf(condition: () => any, b1: BlockFn, b2?: BlockFn, once?: boolean): Block;

type Source = any[] | Record<any, any> | number | Set<any> | Map<any, any>;
export declare const createFor: (src: () => Source, renderItem: (item: ShallowRef<any>, key: ShallowRef<any>, index: ShallowRef<number | undefined>) => Block, getKey?: (item: any, key: any, index?: number) => any, flags?: number, setup?: (_: {
    createSelector: (source: () => any) => (cb: () => void) => void;
}) => void) => VaporFragment;
export declare function createForSlots(rawSource: Source, getSlot: (item: any, key: any, index?: number) => DynamicSlot): DynamicSlot[];
export declare function getRestElement(val: any, keys: string[]): any;
export declare function getDefaultValue(val: any, defaultVal: any): any;

type NodeRef = string | Ref | ((ref: Element) => void);
type RefEl = Element | VaporComponentInstance;
type setRefFn = (el: RefEl, ref: NodeRef, oldRef?: NodeRef, refFor?: boolean) => NodeRef | undefined;
export declare function createTemplateRefSetter(): setRefFn;

export declare function createDynamicComponent(getter: () => any, rawProps?: RawProps | null, rawSlots?: RawSlots | null, isSingleRoot?: boolean): VaporFragment;

export declare function applyVShow(target: Block, source: () => any): void;

type VaporModelDirective<T extends HTMLElement = HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement, Modifiers extends string = string> = (el: T, get: () => any, set: (v: any) => void, modifiers?: {
    [key in Modifiers]?: true;
}) => void;
export declare const applyTextModel: VaporModelDirective<HTMLInputElement | HTMLTextAreaElement, 'trim' | 'number' | 'lazy'>;
export declare const applyCheckboxModel: VaporModelDirective<HTMLInputElement>;
export declare const applyRadioModel: VaporModelDirective<HTMLInputElement>;
export declare const applySelectModel: VaporModelDirective<HTMLSelectElement, 'number'>;
export declare const applyDynamicModel: VaporModelDirective;


